{"meta":{"title":"ghsticker的博客","subtitle":"爱生活，编码的小学僧","description":"爱生活，编码的小学生","author":"ghsticker","url":"http://yoursite.com","root":"/"},"pages":[{"title":"java","date":"2019-07-25T03:16:41.000Z","updated":"2019-07-25T03:16:41.518Z","comments":true,"path":"java/index.html","permalink":"http://yoursite.com/java/index.html","excerpt":"","text":""}],"posts":[{"title":"微信小程序本地测试","slug":"微信小程序本地测试","date":"2019-07-25T10:32:28.000Z","updated":"2019-07-27T08:23:02.805Z","comments":true,"path":"2019/07/25/微信小程序本地测试/","link":"","permalink":"http://yoursite.com/2019/07/25/微信小程序本地测试/","excerpt":"微信小程序本地测试 做微信小程序，服务器写在本地 怎么才能与手机相互连接测试小程序或者直接在本地模拟器上测试呢、","text":"微信小程序本地测试 做微信小程序，服务器写在本地 怎么才能与手机相互连接测试小程序或者直接在本地模拟器上测试呢、 0.本地测试根据微信小程序的官方文档，小程序的通讯域名协议只支持https的，官方文档如下： 我们可以这样修改让小程序开发工具忽略https协议， 在右边详情中可以勾选，不校验https，这样子就可以url就可以是http://localhost:8080 1.手机测试要想在手机端运行你的小程序，可以买个服务器，像是腾讯云，阿里云（微信开发最好买腾讯云），对于小白选手，初学者也可以不需要购买服务器，通过内网穿透工具即可，将本地的服务器映射到公网上，下面介绍几个内网穿透工具： ngrok 中文官网：http://ngrok.cn/ 这个官网国内近还是比较快，要是下载就会GG，最好科学上网 进入官网，点击注册，他会分配一个密钥 下载成功，在本地ngrok.exe的目录下，进入cmd，输入一下，回车 ngrok -authtoken 密钥 -subdomain 二级域名 端口 接下将映射域名，复制到小程序即可 Sunny-Ngrok 官网：https://www.ngrok.cc/ 这个是国内的一个内网穿透工具，网速，下载都相比于ngrok会快。 直接下载需要的客服端，注册，登陆上用户管理上 上面可以选择免费的使用，带宽和速度会慢一些，不过传一般的数据基本没啥为题。 点击免费的购买即可。 贴一下官网的教程；http://www.ngrok.cc/_book/ 以上就能解决小程序本地测试的问题了","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"单链表实现LRU算法","slug":"单链表实现LRU算法","date":"2019-07-25T01:51:36.000Z","updated":"2019-07-25T03:12:36.912Z","comments":true,"path":"2019/07/25/单链表实现LRU算法/","link":"","permalink":"http://yoursite.com/2019/07/25/单链表实现LRU算法/","excerpt":"单链表实现LRU算法 LRU应该是面试中常见的算法题目了，其实实现起来也不是特别的困难，使用的数据结构也是常见的单链表。 下面使用java 实现。","text":"单链表实现LRU算法 LRU应该是面试中常见的算法题目了，其实实现起来也不是特别的困难，使用的数据结构也是常见的单链表。 下面使用java 实现。 0.什么是LRULRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高” 1.思路首先选择合适的数据结构，这里使用的的单链表。 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。 如果此数据没有在缓存链表中，又可以分为两种情况： 如果此时缓存未满，则将此结点直接插入到链表的头部； 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部 2.实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168/** * 用链表实行LRU缓存算法 * 思路：1.若缓存数据在链表中，则先找到这个数据，删除，再插入到链表头部 * 2.若缓存数据不在链表中 * 2.1 链表容量满了，则删除最后一个结点，从头部插入新的结点 * 2.2 链表容量没满，则直接从头部插入 */public class LRUBaseLinkedList&lt;T&gt; &#123; //链表最大容量 private final static Integer DEFAULT_CAPACITY = 10; //头结点 private Node&lt;T&gt; headNode; //长度 private Integer length; //容量 private Integer capacity; public LRUBaseLinkedList() &#123; this.headNode = new Node&lt;&gt;(); this.length = 0; this.capacity = DEFAULT_CAPACITY; &#125; public LRUBaseLinkedList(Integer capacity) &#123; this.headNode = new Node&lt;&gt;(); this.length = 0; this.capacity = capacity; &#125; //LRU public void lru(T data)&#123; Node perNode = findPerNode(data); if(perNode !=null)&#123; deleteElement(perNode); insertElementHead(data); &#125;else&#123; if(length &gt;= this.capacity)&#123; deleteElementEnd(); &#125; insertElementHead(data); &#125; &#125; /** * 删除链表中的最后一个元素 */ private void deleteElementEnd() &#123; Node p = headNode; if(p.next == null) return; while (p.next.next != null) p = p.next; Node end = p.next; p.next = null; end= null; --length; &#125; /** * 在链表头部插入元素 * @param data */ private void insertElementHead(T data) &#123; Node p = headNode.next; Node newNode = new Node(data,p); headNode.next = newNode; length++; &#125; /** * 删除pernode的下一个结点 * @param perNode */ private void deleteElement(Node perNode) &#123; if(perNode != null)&#123; Node temp = perNode.next; perNode.next = temp.next; temp.next = null; length--; &#125; &#125; /** * 获取查找元素的前一个结点 * @param data * @return */ private Node findPerNode(T data) &#123; Node p = headNode; while (p.next != null)&#123; if(p.next.element == data)&#123; return p; &#125; p = p.next; &#125; return null; &#125; /** * 打印 */ private void printAll() &#123; Node node = headNode.next; while (node != null)&#123; System.out.print(node.element+\" \"); node = node.next; &#125; System.out.println(); &#125; //定义结点 public class Node&lt;T&gt;&#123; T element; Node next; public Node() &#123; &#125; public Node(T element, Node next) &#123; this.element = element; this.next = next; &#125; public T getElement() &#123; return element; &#125; public void setElement(T element) &#123; this.element = element; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125; &#125; public static void main(String[] args) &#123; LRUBaseLinkedList&lt;Integer&gt; linkedList = new LRUBaseLinkedList&lt;&gt;(); Scanner sc = new Scanner(System.in); while (sc.hasNext())&#123; linkedList.lru(sc.nextInt()); linkedList.printAll(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"单链表 算法","slug":"单链表-算法","permalink":"http://yoursite.com/tags/单链表-算法/"}]}]}