{"meta":{"title":"ghsticker的博客","subtitle":"爱生活，编码的小学僧","description":"爱生活，编码的小学生","author":"ghsticker","url":"http://yoursite.com","root":"/"},"pages":[{"title":"java","date":"2019-07-25T03:16:41.000Z","updated":"2019-07-25T03:16:41.518Z","comments":true,"path":"java/index.html","permalink":"http://yoursite.com/java/index.html","excerpt":"","text":""}],"posts":[{"title":"单链表实现LRU算法","slug":"单链表实现LRU算法","date":"2019-07-25T01:51:36.000Z","updated":"2019-07-25T03:12:36.912Z","comments":true,"path":"2019/07/25/单链表实现LRU算法/","link":"","permalink":"http://yoursite.com/2019/07/25/单链表实现LRU算法/","excerpt":"单链表实现LRU算法 LRU应该是面试中常见的算法题目了，其实实现起来也不是特别的困难，使用的数据结构也是常见的单链表。 下面使用java 实现。","text":"单链表实现LRU算法 LRU应该是面试中常见的算法题目了，其实实现起来也不是特别的困难，使用的数据结构也是常见的单链表。 下面使用java 实现。 0.什么是LRULRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高” 1.思路首先选择合适的数据结构，这里使用的的单链表。 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。 如果此数据没有在缓存链表中，又可以分为两种情况： 如果此时缓存未满，则将此结点直接插入到链表的头部； 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部 2.实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168/** * 用链表实行LRU缓存算法 * 思路：1.若缓存数据在链表中，则先找到这个数据，删除，再插入到链表头部 * 2.若缓存数据不在链表中 * 2.1 链表容量满了，则删除最后一个结点，从头部插入新的结点 * 2.2 链表容量没满，则直接从头部插入 */public class LRUBaseLinkedList&lt;T&gt; &#123; //链表最大容量 private final static Integer DEFAULT_CAPACITY = 10; //头结点 private Node&lt;T&gt; headNode; //长度 private Integer length; //容量 private Integer capacity; public LRUBaseLinkedList() &#123; this.headNode = new Node&lt;&gt;(); this.length = 0; this.capacity = DEFAULT_CAPACITY; &#125; public LRUBaseLinkedList(Integer capacity) &#123; this.headNode = new Node&lt;&gt;(); this.length = 0; this.capacity = capacity; &#125; //LRU public void lru(T data)&#123; Node perNode = findPerNode(data); if(perNode !=null)&#123; deleteElement(perNode); insertElementHead(data); &#125;else&#123; if(length &gt;= this.capacity)&#123; deleteElementEnd(); &#125; insertElementHead(data); &#125; &#125; /** * 删除链表中的最后一个元素 */ private void deleteElementEnd() &#123; Node p = headNode; if(p.next == null) return; while (p.next.next != null) p = p.next; Node end = p.next; p.next = null; end= null; --length; &#125; /** * 在链表头部插入元素 * @param data */ private void insertElementHead(T data) &#123; Node p = headNode.next; Node newNode = new Node(data,p); headNode.next = newNode; length++; &#125; /** * 删除pernode的下一个结点 * @param perNode */ private void deleteElement(Node perNode) &#123; if(perNode != null)&#123; Node temp = perNode.next; perNode.next = temp.next; temp.next = null; length--; &#125; &#125; /** * 获取查找元素的前一个结点 * @param data * @return */ private Node findPerNode(T data) &#123; Node p = headNode; while (p.next != null)&#123; if(p.next.element == data)&#123; return p; &#125; p = p.next; &#125; return null; &#125; /** * 打印 */ private void printAll() &#123; Node node = headNode.next; while (node != null)&#123; System.out.print(node.element+\" \"); node = node.next; &#125; System.out.println(); &#125; //定义结点 public class Node&lt;T&gt;&#123; T element; Node next; public Node() &#123; &#125; public Node(T element, Node next) &#123; this.element = element; this.next = next; &#125; public T getElement() &#123; return element; &#125; public void setElement(T element) &#123; this.element = element; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125; &#125; public static void main(String[] args) &#123; LRUBaseLinkedList&lt;Integer&gt; linkedList = new LRUBaseLinkedList&lt;&gt;(); Scanner sc = new Scanner(System.in); while (sc.hasNext())&#123; linkedList.lru(sc.nextInt()); linkedList.printAll(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"单链表 算法","slug":"单链表-算法","permalink":"http://yoursite.com/tags/单链表-算法/"}]}]}